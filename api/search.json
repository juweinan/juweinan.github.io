[{"id":"ff294b41f6454d72b979d968dd4769d6","title":"测试","content":"介绍\n\n\n\n\n\n\n\n\ncall：改变函数作用域中的 this 指向且立即执行。\n参数一：&#96;this&#96; 指向的对象\n参数二等：序列。调用函数需要传递的参数列表。\n\n示例：&#96;fn.call(obj, arg1, arg2, ...args)&#96;\n\n\n\n\n\n\n\n\n\n\napply：改变函数作用域中的 this 指向且立即执行。\n参数一：&#96;this&#96; 指向的对象\n参数二：数组。调用函数需要传递的参数。\n\n示例：&#96;fn.apply(obj, [arg1, arg2, ...args])&#96;\n\n\n\n\n\n\n\n\n\n\nbind：改变函数作用域中的 this 指向，不立即执行，但是会返回一个新的函数\n参数一：&#96;this&#96; 指向的对象\n参数二：序列。给函数传递的参数序列。\n        如果这个序列的长度小于命名参数的长度，则调用返回的新函数可以补充剩余的未传递的参数\n        如果这个序列的长度等于命名参数的长度，则调用返回的新函数传递的参数无效\n        如果这个序列的长度大于命名参数的长度，则只截取需要的个数，多余的被忽略\n\n示例：&#96;const newFn &#x3D; fn.bind(obj, arg1, arg2);&#96;\n     &#96;newFn(arg3, arg4);&#96;\n\n手动实现\n\n\n\n\n\n\n\n\ncall\nFunction.prototype.myCall &#x3D; function (context) &#123;\n  &#x2F;**\n   * 防止原型对象上的该方法被直接调用\n   * const myCall &#x3D; Function.prototype.myCall;\n   * myCall();\n   * 这是 this &#x3D;&#x3D;&#x3D; window，下面执行 context[fn]() 的时候会报错\n   *&#x2F;\n  if (typeof this !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    return undefined;\n  &#125;\n  &#x2F;&#x2F; 如果 context 为 null 或者 undefined，则默认为 window\n  if (context &#x3D;&#x3D;&#x3D; null || context &#x3D;&#x3D;&#x3D; undefined) &#123;\n    context &#x3D; window;\n  &#125; else &#123;\n    &#x2F;&#x2F; 否则就包装成 Object 类型（这里主要是针对原始值做处理）\n    context &#x3D; Object(context);\n  &#125;\n  &#x2F;&#x2F; 这个 context 对象将会作为调用 myCall 方法的函数体内部的 this 指向\n\n  &#x2F;&#x2F; 获取除了第一个以外的所有参数\n  const args &#x3D; [...arguments].slice(1);\n  &#x2F;&#x2F; 定义一个 Symbol 类型的变量\n  const fn &#x3D; Symbol();\n  &#x2F;&#x2F; 让 Symbol 类型的变量作为 context 的 key，值为被执行的函数体\n  &#x2F;&#x2F; (这里的 this 指向的是调用 myCall 方法的函数体，context 代表的是调用该方法的函数体内部的 this)\n  context[fn] &#x3D; this;\n  &#x2F;**\n   * context: &#123;\n   *   props: ...,\n   *   Symbol(): this\n   * &#125;\n   *&#x2F;\n  &#x2F;&#x2F; 执行对象中的方法，因此方法内部的 this 就会指向该对象\n  const result &#x3D; context[fn](...args);\n  &#x2F;&#x2F; 得到结果就在对象中删除该方法，防止污染 context 对象\n  delete context[fn];\n  &#x2F;&#x2F; 返回结果\n  return result;\n&#125;;\n\n\n\n\n\n\n\n\n\n\napply\napply 和 call 的实现方式很相似。唯一不同的是，前者接收传递给函数的参数是 &#x3D;&#x3D;数组类型&#x3D;&#x3D;，后者接收传递给函数的参数是 &#x3D;&#x3D;序列&#x3D;&#x3D;。\nFunction.prototype.myApply &#x3D; function (context) &#123;\n  if (typeof this !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    return undefined;\n  &#125;\n  if (context &#x3D;&#x3D;&#x3D; null || context &#x3D;&#x3D;&#x3D; undefined) &#123;\n    context &#x3D; window;\n  &#125; else &#123;\n    context &#x3D; Object(context);\n  &#125;\n\n  const fn &#x3D; Symbol();\n  context[fn] &#x3D; this;\n  let result;\n  &#x2F;&#x2F; call 和 apply 的区别是除了第一个参数以外的其他参数的传递方式\n  if (arguments[1] instanceof Array) &#123;\n    result &#x3D; context[fn](...arguments[1]); &#x2F;&#x2F; 如果第二个参数是数组，则作为参数传递给函数\n  &#125; else &#123;\n    result &#x3D; context[fn](); &#x2F;&#x2F; 不是数组 什么也不传\n  &#125;\n  delete context[fn];\n  return result;\n&#125;;\n\n\n\n\n\n\n\n\n\n\nbind\nFunction.prototype.myBind &#x3D; function (context) &#123;\n  &#x2F;**\n   * 这里判断 this 是否为 function 与 myCall 和 myApply 不同的是，\n   * myCall 和 myApply 是立即执行的，当调用错误时返回 undefined 也没问题\n   * 而 myBind 返回的是一个新的函数，因此直接给报错更合理\n   *&#x2F;\n  if (typeof this !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    throw new TypeError(&#39;error&#39;);\n  &#125;\n\n  &#x2F;&#x2F; 缓存调用 bind 方法的函数体，以及调用 bind 方法时传递的参数\n  const _this &#x3D; this;\n  const args &#x3D; [...arguments].slice(1);\n\n  &#x2F;&#x2F; bind 方法不是立即执行的，而是会返回一个新的函数\n  return function F() &#123;\n    &#x2F;&#x2F; 如果返回的新的函数是通过 new 调用的，则返回调用 bind 方法的函数体的实例对象\n    if (this instanceof F) &#123;\n      &#x2F;&#x2F; 这里 args 是调用 bind 方法传递给函数体的参数，arguments 是调用返回的新的函数时传递的参数\n      return new _this(...args, ...arguments);\n    &#125; else &#123;\n      &#x2F;&#x2F; 正常调用返回的新的函数，已经缓存了调用方法的函数体，和函数体内部的 this 指向，因此相当于调用 myApply，或者 myCall 方法\n      return _this.myApply(context, [...args, ...arguments]);\n    &#125;\n  &#125;;\n&#125;;\n\n无注释版本&#x2F;&#x2F; call\nFunction.prototype.myCall &#x3D; function (context) &#123;\n  if (typeof this !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    return undefined;\n  &#125;\n  if (context &#x3D;&#x3D;&#x3D; null || context &#x3D;&#x3D;&#x3D; undefined) &#123;\n    context &#x3D; window;\n  &#125; else &#123;\n    context &#x3D; Object(context);\n  &#125;\n  const args &#x3D; [...arguments].slice(1);\n  const fn &#x3D; Symbol();\n  context[fn] &#x3D; this;\n  const result &#x3D; context[fn](...args);\n  delete context[fn];\n  return result;\n&#125;;\n\n&#x2F;&#x2F; apply\nFunction.prototype.myApply &#x3D; function (context) &#123;\n  if (typeof this !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    return undefined;\n  &#125;\n  if (context &#x3D;&#x3D;&#x3D; null || context &#x3D;&#x3D;&#x3D; undefined) &#123;\n    context &#x3D; window;\n  &#125; else &#123;\n    context &#x3D; Object(context);\n  &#125;\n\n  const fn &#x3D; Symbol();\n  context[fn] &#x3D; this;\n  let result;\n  if (arguments[1] instanceof Array) &#123;\n    result &#x3D; context[fn](...arguments[1]);\n  &#125; else &#123;\n    result &#x3D; context[fn]();\n  &#125;\n  delete context[fn];\n  return result;\n&#125;;\n\n&#x2F;&#x2F; bind\nFunction.prototype.myBind &#x3D; function (context) &#123;\n  if (typeof this !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    throw new TypeError(&#39;error&#39;);\n  &#125;\n  const _this &#x3D; this;\n  const args &#x3D; [...arguments].slice(1);\n  return function F() &#123;\n    if (this instanceof F) &#123;\n      return new _this(...args, ...arguments);\n    &#125; else &#123;\n      return _this.myApply(context, [...args, ...arguments]);\n    &#125;\n  &#125;;\n&#125;;\n","slug":"测试","date":"2023-04-25T15:17:42.362Z","categories_index":"","tags_index":"","author_index":"Juzzzi"},{"id":"581e98227d534136b65e643d2b7dc9ab","title":"如何实现 call、apply、bind？","content":"介绍\n\n\n\n\n\n\n\n\ncall：改变函数作用域中的 this 指向且立即执行。\n参数一：&#96;this&#96; 指向的对象\n参数二等：序列。调用函数需要传递的参数列表。\n\n示例：&#96;fn.call(obj, arg1, arg2, ...args)&#96;\n\n\n\n\n\n\n\n\n\n\napply：改变函数作用域中的 this 指向且立即执行。\n参数一：&#96;this&#96; 指向的对象\n参数二：数组。调用函数需要传递的参数。\n\n示例：&#96;fn.apply(obj, [arg1, arg2, ...args])&#96;\n\n\n\n\n\n\n\n\n\n\nbind：改变函数作用域中的 this 指向，不立即执行，但是会返回一个新的函数\n参数一：&#96;this&#96; 指向的对象\n参数二：序列。给函数传递的参数序列。\n        如果这个序列的长度小于命名参数的长度，则调用返回的新函数可以补充剩余的未传递的参数\n        如果这个序列的长度等于命名参数的长度，则调用返回的新函数传递的参数无效\n        如果这个序列的长度大于命名参数的长度，则只截取需要的个数，多余的被忽略\n\n示例：&#96;const newFn &#x3D; fn.bind(obj, arg1, arg2);&#96;\n     &#96;newFn(arg3, arg4);&#96;\n\n手动实现\n\n\n\n\n\n\n\n\ncall\nFunction.prototype.myCall &#x3D; function (context) &#123;\n  &#x2F;**\n   * 防止原型对象上的该方法被直接调用\n   * const myCall &#x3D; Function.prototype.myCall;\n   * myCall();\n   * 这是 this &#x3D;&#x3D;&#x3D; window，下面执行 context[fn]() 的时候会报错\n   *&#x2F;\n  if (typeof this !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    return undefined;\n  &#125;\n  &#x2F;&#x2F; 如果 context 为 null 或者 undefined，则默认为 window\n  if (context &#x3D;&#x3D;&#x3D; null || context &#x3D;&#x3D;&#x3D; undefined) &#123;\n    context &#x3D; window;\n  &#125; else &#123;\n    &#x2F;&#x2F; 否则就包装成 Object 类型（这里主要是针对原始值做处理）\n    context &#x3D; Object(context);\n  &#125;\n  &#x2F;&#x2F; 这个 context 对象将会作为调用 myCall 方法的函数体内部的 this 指向\n\n  &#x2F;&#x2F; 获取除了第一个以外的所有参数\n  const args &#x3D; [...arguments].slice(1);\n  &#x2F;&#x2F; 定义一个 Symbol 类型的变量\n  const fn &#x3D; Symbol();\n  &#x2F;&#x2F; 让 Symbol 类型的变量作为 context 的 key，值为被执行的函数体\n  &#x2F;&#x2F; (这里的 this 指向的是调用 myCall 方法的函数体，context 代表的是调用该方法的函数体内部的 this)\n  context[fn] &#x3D; this;\n  &#x2F;**\n   * context: &#123;\n   *   props: ...,\n   *   Symbol(): this\n   * &#125;\n   *&#x2F;\n  &#x2F;&#x2F; 执行对象中的方法，因此方法内部的 this 就会指向该对象\n  const result &#x3D; context[fn](...args);\n  &#x2F;&#x2F; 得到结果就在对象中删除该方法，防止污染 context 对象\n  delete context[fn];\n  &#x2F;&#x2F; 返回结果\n  return result;\n&#125;;\n\n\n\n\n\n\n\n\n\n\napply\napply 和 call 的实现方式很相似。唯一不同的是，前者接收传递给函数的参数是 &#x3D;&#x3D;数组类型&#x3D;&#x3D;，后者接收传递给函数的参数是 &#x3D;&#x3D;序列&#x3D;&#x3D;。\nFunction.prototype.myApply &#x3D; function (context) &#123;\n  if (typeof this !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    return undefined;\n  &#125;\n  if (context &#x3D;&#x3D;&#x3D; null || context &#x3D;&#x3D;&#x3D; undefined) &#123;\n    context &#x3D; window;\n  &#125; else &#123;\n    context &#x3D; Object(context);\n  &#125;\n\n  const fn &#x3D; Symbol();\n  context[fn] &#x3D; this;\n  let result;\n  &#x2F;&#x2F; call 和 apply 的区别是除了第一个参数以外的其他参数的传递方式\n  if (arguments[1] instanceof Array) &#123;\n    result &#x3D; context[fn](...arguments[1]); &#x2F;&#x2F; 如果第二个参数是数组，则作为参数传递给函数\n  &#125; else &#123;\n    result &#x3D; context[fn](); &#x2F;&#x2F; 不是数组 什么也不传\n  &#125;\n  delete context[fn];\n  return result;\n&#125;;\n\n\n\n\n\n\n\n\n\n\nbind\nFunction.prototype.myBind &#x3D; function (context) &#123;\n  &#x2F;**\n   * 这里判断 this 是否为 function 与 myCall 和 myApply 不同的是，\n   * myCall 和 myApply 是立即执行的，当调用错误时返回 undefined 也没问题\n   * 而 myBind 返回的是一个新的函数，因此直接给报错更合理\n   *&#x2F;\n  if (typeof this !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    throw new TypeError(&#39;error&#39;);\n  &#125;\n\n  &#x2F;&#x2F; 缓存调用 bind 方法的函数体，以及调用 bind 方法时传递的参数\n  const _this &#x3D; this;\n  const args &#x3D; [...arguments].slice(1);\n\n  &#x2F;&#x2F; bind 方法不是立即执行的，而是会返回一个新的函数\n  return function F() &#123;\n    &#x2F;&#x2F; 如果返回的新的函数是通过 new 调用的，则返回调用 bind 方法的函数体的实例对象\n    if (this instanceof F) &#123;\n      &#x2F;&#x2F; 这里 args 是调用 bind 方法传递给函数体的参数，arguments 是调用返回的新的函数时传递的参数\n      return new _this(...args, ...arguments);\n    &#125; else &#123;\n      &#x2F;&#x2F; 正常调用返回的新的函数，已经缓存了调用方法的函数体，和函数体内部的 this 指向，因此相当于调用 myApply，或者 myCall 方法\n      return _this.myApply(context, [...args, ...arguments]);\n    &#125;\n  &#125;;\n&#125;;\n\n无注释版本&#x2F;&#x2F; call\nFunction.prototype.myCall &#x3D; function (context) &#123;\n  if (typeof this !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    return undefined;\n  &#125;\n  if (context &#x3D;&#x3D;&#x3D; null || context &#x3D;&#x3D;&#x3D; undefined) &#123;\n    context &#x3D; window;\n  &#125; else &#123;\n    context &#x3D; Object(context);\n  &#125;\n  const args &#x3D; [...arguments].slice(1);\n  const fn &#x3D; Symbol();\n  context[fn] &#x3D; this;\n  const result &#x3D; context[fn](...args);\n  delete context[fn];\n  return result;\n&#125;;\n\n&#x2F;&#x2F; apply\nFunction.prototype.myApply &#x3D; function (context) &#123;\n  if (typeof this !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    return undefined;\n  &#125;\n  if (context &#x3D;&#x3D;&#x3D; null || context &#x3D;&#x3D;&#x3D; undefined) &#123;\n    context &#x3D; window;\n  &#125; else &#123;\n    context &#x3D; Object(context);\n  &#125;\n\n  const fn &#x3D; Symbol();\n  context[fn] &#x3D; this;\n  let result;\n  if (arguments[1] instanceof Array) &#123;\n    result &#x3D; context[fn](...arguments[1]);\n  &#125; else &#123;\n    result &#x3D; context[fn]();\n  &#125;\n  delete context[fn];\n  return result;\n&#125;;\n\n&#x2F;&#x2F; bind\nFunction.prototype.myBind &#x3D; function (context) &#123;\n  if (typeof this !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    throw new TypeError(&#39;error&#39;);\n  &#125;\n  const _this &#x3D; this;\n  const args &#x3D; [...arguments].slice(1);\n  return function F() &#123;\n    if (this instanceof F) &#123;\n      return new _this(...args, ...arguments);\n    &#125; else &#123;\n      return _this.myApply(context, [...args, ...arguments]);\n    &#125;\n  &#125;;\n&#125;;\n","slug":"手写call、apply、bind","date":"2023-04-25T15:17:42.362Z","categories_index":"","tags_index":"","author_index":"Juzzzi"},{"id":"bd4cb6da856d09a092e029f0eb2ac7c0","title":"微信小程序实现星巴克类似的底部导航","content":"实现星巴克类似的底部导航实现样式例图\n\n自定义导航 custom-footer&lt;!-- components&#x2F;custom-footer&#x2F;custom-footer.wxml --&gt;\n&lt;!-- 底部导航栏容器-自定义背景颜色-兼容 iPhoneX 底部横线 --&gt;\n&lt;view\n  class&#x3D;&quot;tabbar_box &#123;&#123;isIphoneX ? &#39;iphoneX-height&#39; : &#39;&#39;&#125;&#125;&quot;\n  style&#x3D;&quot;background: &#123;&#123;tabbar.backgroundColor&#125;&#125;&quot;\n&gt;\n  &lt;block wx:for&#x3D;&quot;&#123;&#123;tabbar.list&#125;&#125;&quot; wx:key&#x3D;&quot;&#123;&#123;item.pagePath&#125;&#125;&quot;&gt;\n    &lt;!-- 凸起的导航按钮 --&gt;\n    &lt;navigator\n      wx:if&#x3D;&quot;&#123;&#123;item.isSpecial&#125;&#125;&quot;\n      style&#x3D;&quot;color: &#123;&#123;tabbar.color&#125;&#125;&quot;\n      class&#x3D;&quot;tabbar_nav&quot;\n      hover-class&#x3D;&quot;none&quot;\n      url&#x3D;&quot;&#123;&#123;item.pagePath&#125;&#125;&quot;\n      data-url&#x3D;&quot;&#123;&#123;item.pagePath&#125;&#125;&quot;\n      open-type&#x3D;&quot;switchTab&quot;\n    &gt;\n      &lt;!-- 针对凸起部分的图片容器进行定位，图片放大 --&gt;\n      &lt;view class&#x3D;&quot;special-wrapper&quot;&gt;\n        &lt;image class&#x3D;&quot;tabbar_icon&quot; src&#x3D;&quot;&#123;&#123;item.iconPath&#125;&#125;&quot;&gt;&lt;&#x2F;image&gt;\n      &lt;&#x2F;view&gt;\n      &lt;!-- 占位元素-flex 居中布局，不加占位的话文字会跑到中间 --&gt;\n      &lt;image class&#x3D;&quot;special-text-wrapper&quot;&gt;&lt;&#x2F;image&gt;\n      &lt;text&gt;&#123;&#123;item.text&#125;&#125;&lt;&#x2F;text&gt;\n    &lt;&#x2F;navigator&gt;\n    &lt;!-- 正常的底部导航按钮 --&gt;\n    &lt;navigator\n      wx:else\n      style&#x3D;&quot;color: &#123;&#123;item.selected ? tabbar.selectedColor : tabbar.color&#125;&#125;&quot;\n      class&#x3D;&quot;tabbar_nav&quot;\n      hover-class&#x3D;&quot;none&quot;\n      url&#x3D;&quot;&#123;&#123;item.pagePath&#125;&#125;&quot;\n      open-type&#x3D;&quot;switchTab&quot;\n    &gt;\n      &lt;!-- 根据当前的选中状态展示图片 --&gt;\n      &lt;image\n        class&#x3D;&quot;tabbar_icon&quot;\n        src&#x3D;&quot;&#123;&#123;item.selected ? item.selectedIconPath : item.iconPath&#125;&#125;&quot;\n      &gt;&lt;&#x2F;image&gt;\n      &lt;text&gt;&#123;&#123;item.text&#125;&#125;&lt;&#x2F;text&gt;\n    &lt;&#x2F;navigator&gt;\n  &lt;&#x2F;block&gt;\n&lt;&#x2F;view&gt;\n\n&#x2F;* components&#x2F;custom-footer&#x2F;custom-footer.wxss *&#x2F;\n&#x2F;* 定位在底部以及整体大小布局等 *&#x2F;\n.tabbar_box &#123;\n  position: fixed;\n  left: 0;\n  bottom: 0;\n  z-index: 999;\n  width: 100%;\n  height: 98rpx;\n  display: flex;\n  justify-content: space-around;\n  box-shadow: 0 -12rpx 40rpx -10rpx #ccc;\n&#125;\n\n&#x2F;* 兼容 iPhoneX 横线 *&#x2F;\n.iphoneX-height &#123;\n  padding-bottom: 66rpx;\n&#125;\n\n&#x2F;* 正常的每一个菜单导航按钮选项 *&#x2F;\n.tabbar_nav &#123;\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  font-size: 20rpx;\n  height: 100%;\n  position: relative;\n&#125;\n\n&#x2F;* 导航菜单按钮图标 *&#x2F;\n.tabbar_icon &#123;\n  width: 50rpx;\n  height: 50rpx;\n&#125;\n\n&#x2F;* 特殊导航-凸起的样式-定位+圆角+边框 *&#x2F;\n.special-wrapper &#123;\n  position: absolute;\n  top: -52rpx;\n  width: 113rpx;\n  height: 113rpx;\n  border-radius: 50%;\n  background: #fff;\n  text-align: center;\n  box-sizing: border-box;\n  padding: 6rpx;\n  box-shadow: 0 -12rpx 40rpx -10rpx #ccc;\n&#125;\n\n&#x2F;* 凸起的图片大小重新设置 *&#x2F;\n.special-wrapper .tabbar_icon &#123;\n  width: 88rpx;\n  height: 88rpx;\n  padding-top: 7rpx;\n&#125;\n\n&#x2F;* 占位-防止凸起样式的文字跑到上面 *&#x2F;\n.special-text-wrapper &#123;\n  width: 56rpx;\n  height: 56rpx;\n&#125;\n\n&#x2F;&#x2F; components&#x2F;custom-footer&#x2F;custom-footer.js\nComponent(&#123;\n  &#x2F;**\n   * 组件的属性列表\n   *&#x2F;\n  properties: &#123;\n    tabbar: Object,\n  &#125;,\n&#125;);\n\n在编写完上面的代码后，自定义组件的结构样式已经完成了。下面就是改如何使用了，不过在使用之前需要注意一下几点\n在 app.json 中配置小程序自带的导航配置默认的导航需要遵循小程序的规则：\n\n菜单项不能少于两项\npagePath 中必须和 pages 中的保持一致\n\n这里只做了简单配置\n&#123;\n  &quot;pages&quot;: [\n    &quot;pages&#x2F;index&#x2F;index&quot;,\n    &quot;pages&#x2F;logs&#x2F;logs&quot;,\n    &quot;pages&#x2F;page1&#x2F;page1&quot;,\n    &quot;pages&#x2F;page2&#x2F;page2&quot;,\n    &quot;pages&#x2F;page3&#x2F;page3&quot;\n  ],\n  &quot;tabBar&quot;: &#123;\n    &quot;list&quot;: [\n      &#123;\n        &quot;pagePath&quot;: &quot;pages&#x2F;index&#x2F;index&quot;,\n        &quot;text&quot;: &quot;首页&quot;\n      &#125;,\n      &#123;\n        &quot;pagePath&quot;: &quot;pages&#x2F;logs&#x2F;logs&quot;,\n        &quot;text&quot;: &quot;日志&quot;\n      &#125;,\n      &#123;\n        &quot;pagePath&quot;: &quot;pages&#x2F;page1&#x2F;page1&quot;,\n        &quot;text&quot;: &quot;页面1&quot;\n      &#125;,\n      &#123;\n        &quot;pagePath&quot;: &quot;pages&#x2F;page2&#x2F;page2&quot;,\n        &quot;text&quot;: &quot;页面2&quot;\n      &#125;,\n      &#123;\n        &quot;pagePath&quot;: &quot;pages&#x2F;page3&#x2F;page3&quot;,\n        &quot;text&quot;: &quot;页面3&quot;\n      &#125;\n    ]\n  &#125;,\n&#125;\n\n问：我们要使用自定义导航，为什么还要配置默认导航呢？\n\n\n\n\n\n\n\n\n个人理解是因为自定义导航是在默认导航的基础上完成的，而且 tabbar 导航是不进入路由栈的。而且实践证明，如果这里面配置的路由和自定义路由的数量和路由不一致，会导致无法跳转页面。因此这不是必须要做的。\n做完这些工作后，页面中应该是会出现自定义底部导航栏的。\n使用自定义导航\n在每一个需要展示自定义导航的页面引用导航组件。这些页面通常是底部导航跳转路由对应的页面。\n在每个页面中都执行 app.editTabbar()。原因后面讲，少安毋躁。\n\n代码如下：\n&lt;!--pages&#x2F;index&#x2F;index.wxml--&gt;\n&lt;custom-footer tabbar&#x3D;&quot;&#123;&#123;tabbar&#125;&#125;&quot;&gt;&lt;&#x2F;custom-footer&gt;\n\n&#x2F;&#x2F; pages&#x2F;index&#x2F;index.js\nconst app &#x3D; getApp();\nPage(&#123;\n  &#x2F;**\n   * 生命周期函数--监听页面加载\n   *&#x2F;\n  onLoad: function (options) &#123;\n    app.editTabbar();\n  &#125;,\n&#125;);\n\n&#123;\n  &quot;usingComponents&quot;: &#123;\n    &quot;custom-footer&quot;: &quot;&#x2F;components&#x2F;custom-footer&#x2F;custom-footer&quot;\n  &#125;\n&#125;\n\n这时页面中可能会展示自定义导航栏，但是只能看还不能用。。。\n让自定义导航栏代替默认导航\n自定义导航中的 pagePath 必须和 app.json 中配置的 pagePath 保持一致\n\n&#x2F;&#x2F; app.js\nApp(&#123;\n  onLaunch() &#123;\n    this.getHeaderInfo();\n  &#125;,\n  globalData: &#123;\n    &#x2F;&#x2F; 导航相关的数据，具体属性不详细介绍\n    tabBar: &#123;\n      backgroundColor: &#39;#ffffff&#39;,\n      color: &#39;#333333&#39;,\n      selectedColor: &#39;#26C55E&#39;,\n      &#x2F;&#x2F; 这里的路由必须和 app.json 中配置的路径一样\n      list: [\n        &#123;\n          pagePath: &#39;&#x2F;pages&#x2F;index&#x2F;index&#39;,\n          text: &#39;首页&#39;,\n          iconPath: &#39;&#x2F;assets&#x2F;images&#x2F;preview.png&#39;,\n          selectedIconPath: &#39;&#x2F;assets&#x2F;images&#x2F;preview.png&#39;,\n        &#125;,\n        &#123;\n          pagePath: &#39;&#x2F;pages&#x2F;logs&#x2F;logs&#39;,\n          text: &#39;日志&#39;,\n          iconPath: &#39;&#x2F;assets&#x2F;images&#x2F;preview.png&#39;,\n          selectedIconPath: &#39;&#x2F;assets&#x2F;images&#x2F;preview.png&#39;,\n        &#125;,\n        &#123;\n          pagePath: &#39;&#x2F;pages&#x2F;page1&#x2F;page1&#39;,\n          isSpecial: true, &#x2F;&#x2F; 特殊的导航，在这里值得是当前导航是凸起的部分\n          text: &#39;页面1&#39;,\n          iconPath: &#39;&#x2F;assets&#x2F;images&#x2F;preview.png&#39;,\n          selectedIconPath: &#39;&#x2F;assets&#x2F;images&#x2F;preview.png&#39;,\n        &#125;,\n        &#123;\n          pagePath: &#39;&#x2F;pages&#x2F;page2&#x2F;page2&#39;,\n          text: &#39;页面2&#39;,\n          iconPath: &#39;&#x2F;assets&#x2F;images&#x2F;preview.png&#39;,\n          selectedIconPath: &#39;&#x2F;assets&#x2F;images&#x2F;preview.png&#39;,\n        &#125;,\n        &#123;\n          pagePath: &#39;&#x2F;pages&#x2F;page3&#x2F;page3&#39;,\n          text: &#39;页面3&#39;,\n          iconPath: &#39;&#x2F;assets&#x2F;images&#x2F;preview.png&#39;,\n          selectedIconPath: &#39;&#x2F;assets&#x2F;images&#x2F;preview.png&#39;,\n        &#125;,\n      ],\n    &#125;,\n  &#125;,\n\n  &#x2F;&#x2F; 编辑导航方法\n  editTabbar() &#123;\n    &#x2F;&#x2F;隐藏系统tabbar\n    wx.hideTabBar();\n    let tabbar &#x3D; this.globalData.tabBar;\n    let currentPages &#x3D; getCurrentPages();\n    &#x2F;&#x2F; 拿到当前页面。这里面的 _this 对应的就是当前页面的引用\n    let _this &#x3D; currentPages[currentPages.length - 1];\n    &#x2F;&#x2F; 取出当前页面的路由\n    let pagePath &#x3D; _this.route;\n    &#x2F;&#x2F; 让路由第一个字符是 &#x2F;\n    pagePath.indexOf(&#39;&#x2F;&#39;) !&#x3D; 0 &amp;&amp; (pagePath &#x3D; &#39;&#x2F;&#39; + pagePath);\n    &#x2F;&#x2F; 遍历数组，先让所有的都是非选中状态，只有当前路由对应的是选中的\n    for (let i in tabbar.list) &#123;\n      tabbar.list[i].selected &#x3D; false;\n      tabbar.list[i].pagePath &#x3D;&#x3D; pagePath &amp;&amp; (tabbar.list[i].selected &#x3D; true);\n    &#125;\n    _this.setData(&#123; tabbar &#125;); &#x2F;&#x2F; 修改当前选中的页面的 tabbar 数据\n  &#125;,\n&#125;);\n\n也就是说，在每个使用自定义导航的页面中必须先隐藏系统默认的导航。而且这里面 setData 也是修改的选中页面的数据，这也是为什么页面中使用组件时为什么可以传递 tabbar 参数的原因。\n经过这些处理，自定义导航就可以使用了，至于样式颜色图标等就根据业务自定义就好了。\n","slug":"实现星巴克类似的底部导航","date":"2023-04-25T15:17:42.362Z","categories_index":"","tags_index":"","author_index":"Juzzzi"}]